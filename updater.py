from playwright.async_api import async_playwright
from flask import Flask, render_template_string
import logging
import dotenv
import asyncio
import os

logging.basicConfig(level=logging.INFO) # configuring the logger to info log levek

# edit these values in creds.env before running
dotenv.load_dotenv('creds.env')
EMAIL = os.getenv('EMAIL')
PASSWORD = os.getenv('PASSWORD')
COOKIE_FILE_NAME = os.getenv('COOKIE_FILE_NAME')

app = Flask(__name__) # flask init

@app.route('/')
def start_flask():
    '''Start flask default route which listens on port 8080 at 0.0.0.0 
    and render a simple html button for testing purposes'''

    # send a msg to /run_container as POST request and trigger cookie extraction
    return render_template_string(
        '''<html>
            <head>
                <title>Send POST Request</title>
                <style>
                    body {margin: 0;height: 100vh; display: flex;justify-content: center; align-items: center;  background: #f9f9f9;}
                    button {background:#ffb697;color: #101c11;font-weight: 600;border: none;border-radius: 8px;padding: 14px 0;font-size: 1.08rem;cursor: pointer;width: 50%;max-width: 300px; box-sizing: border-box;}
                </style>
            </head>
            <body>
                <button id="sendPost" onClick="sendPost()">Click to send POST request</button>
                <script>
                    async function sendPost(){
                        console.log("button pressed")
                        
                        const reply = await fetch('/run_container', { 
                            method: "POST", headers: {'content-type': 'application/json'}, body: JSON.stringify({ 'message': 'This is the POST request msg' })
                        })
                    }
                </script>
            </body>
            </html>'''
        )

@app.route('/run_container', methods=['POST'])
def run_container():
    async def update_execute():
        '''Execute async function when a POST request is sent to 
        /run_container route of the flask app. Will return a reply in 
        the format of a 200 Http status code when completed'''

        # initialize variables and retreive credentials from env file 
        browser = context = page = cookies = ''

        async with async_playwright() as browser_init: 
            logging.info('Opening browser...')

            # use chrome inside of virtual display
            browser = await browser_init.chromium.launch(
                headless=False, channel='chrome', 
                args=[
                    '--disable-blink-features=AutomationControlled',
                    '--no-sandbox',
                    '--disable-dev-shm-usage'
                    ]
            ) 

            context = await browser.new_context() 
            page = await context.new_page()

            # sign in to provided google account to access YouTube account
            logging.info('Signing in...')
            await page.goto("https://accounts.google.com/signin/v2/identifier")
            await page.get_by_role('textbox').fill(EMAIL) # enter EMAIL 
            await page.get_by_text('Next').click()
            await page.wait_for_timeout(10000)

            await page.get_by_role('textbox').fill(PASSWORD) # enter password
            await page.get_by_text('Next').click() 
            await page.wait_for_timeout(10000)

            # redirect to YouTube and get cookie as json
            logging.info('Redirecting to YouTube for cookie extraction...')
            await page.goto("https://www.youtube.com/") 
            await page.wait_for_timeout(5000)

            cookies = await context.cookies()

            # convert cookies retreived in json to netscape in order to be compatible with yt-dlp
            file = open(COOKIE_FILE_NAME, 'w') # can edit output filename in creds.env
            file.write("# Netscape HTTP Cookie File\n# https://curl.haxx.se/docs/http-cookies.html\n# This file was generated by libcurl! Edit at your own risk.\n\n")
            for dict in cookies:
                if dict['httpOnly']: file.write('#HttpOnly_')
                file.write(f'{dict['domain']}'+'\t'+
                           f'{"TRUE" if dict['domain'][0] == "." else "FALSE"}'+'\t'+
                           f'{dict['path']}'+'\t'+
                           f'{"TRUE" if dict['secure'] else "FALSE"}'+'\t'+'0'+'\t'+
                           f'{dict['name']}'+'\t'+
                           f'{dict['value']}\n')
            file.close()
            await browser.close()

    asyncio.run(update_execute()) # start async function
    with open(COOKIE_FILE_NAME, 'r') as f:
        logging.info(f'Cookie file has been updated.\n\n{f.read()}') # show contents of cookiefile.txt
    return "Service finished running", 200

if __name__ == "__main__":
    # run on 8080 port by default. remove this if necessary
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", 8080)))
